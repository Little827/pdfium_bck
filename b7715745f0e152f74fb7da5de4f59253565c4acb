{
  "comments": [
    {
      "key": {
        "uuid": "6c9414e0_9c0589ec",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 39,
      "author": {
        "id": 5045
      },
      "writtenOn": "2019-11-22T17:35:36Z",
      "side": 1,
      "message": "Feels like this can be integrated into StringToCode().",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0359a162_aa783199",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 39,
      "author": {
        "id": 7613
      },
      "writtenOn": "2019-11-22T19:47:06Z",
      "side": 1,
      "message": "The combination might get a bit long, but I agree there are some redundant checks here, like the branch on the initial \u0027\u003c\u0027 character, and only have one loop that scans over the string would be easier to read. Merging them together might make it more obvious what might make sense as a separate function.\n\nOne possible split might be a decimal and a hexadecimal path (since those have different validation rules), but there would still be common logic for things checking overflow. (Although for hexadecimal, an alternate implementation would be to just count characters...)",
      "parentUuid": "6c9414e0_9c0589ec",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "53a4eb27_dd4ebbf6",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 39,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-11-25T17:53:28Z",
      "side": 1,
      "message": "To eventually fix the parsing error that happens in HandleBeginBFRange(), the code strings need to be validated before calling StringToWideString() or within StringToWideString(). \n\nIf validation is done before calling StringToWideString(), the code will be something like:\n    ......\n    ByteStringView start \u003d pParser-\u003eGetWord();\n    if(start !\u003d \"[\" \u0026\u0026 !IsValidCodeString(start)) {\n        // ivalid character detected\n        return false;\n    }\n\n    if (start \u003d\u003d \"[\") {\n      for (uint32_t code \u003d lowcode; code \u003c\u003d highcode; code++) {\n        auto codestr \u003d pParser-\u003eGetWord();\n        if( !IsValidCodeString(codestr)) \n          return false;\n        SetCode(code, StringToWideString(codestr));\n    }\n      pParser-\u003eGetWord();\n      continue;\n    }\n\n    WideString destcode \u003d StringToWideString(start);\n    ......\n\nRight now I prefer to merge the string validation part into StringToWideString(), just like what we are doing in StringToCode(), and make StringToWideString() return a empty wide string when it detects error.\n\nSince the validation process needs to be included in both functions, maybe we should still keep IsValidCodeString() as a separate function to reduce redundancy?\n\nAnother question is maybe we can broaden the scope of this current CL to include making StringToWideString() more robust too?",
      "parentUuid": "0359a162_aa783199",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9799eb51_6965f373",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 39,
      "author": {
        "id": 7613
      },
      "writtenOn": "2019-11-26T03:36:31Z",
      "side": 1,
      "message": "We can check up front that the word is either a decimal or a hexadecimal string. From there, the per character checks are pretty simple, so I don\u0027t think we would gain much from having a separate IsValidCodeString() phase (which would boil down to the isdigit()/isxdigit() check).\n\nSide note: According to the CMap spec (technical note #5014), both StringToWideString() and StringToCode() should be consuming hexadecimal values only, which might simplify things. (We may have out-of-spec CMaps that use decimal, though; not sure how worried to be about that. Presumably, we have test cases where decimal was required?)\n\nMeta-comment: It\u0027d be nice if we could share code with CPDF_CMapParser. (In fact, the GetCode() function there already uses checked numerics.)\n\nEmbedded CMaps used for encoding are somewhat different from CMaps used for ToUnicode (different operators are allowed, and ToUnicode maps can have destination strings of up to 512 bytes; compare 9.7.5.4 vs. 9.10.3). Still, it seems like there\u0027d be a common subset of functionality that we could unify here.",
      "parentUuid": "53a4eb27_dd4ebbf6",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d803b49e_9dea3e11",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 102,
      "author": {
        "id": 7613
      },
      "writtenOn": "2019-11-22T19:47:06Z",
      "side": 1,
      "message": "Since we\u0027re not actually decoding the UTF-16BE in this function (yet?), I would make a note that the highest valid UTF-16BE value is going to be encoded as DBFFDFFF (which is still less than std::numeric_limits\u003cuint32_t\u003e::max()). The 21 bit limit (maximum code point is U+10FFFF) only applies after decoding",
      "range": {
        "startLine": 102,
        "startChar": 32,
        "endLine": 102,
        "endChar": 39
      },
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ade5bfc7_6bfc288e",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 102,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-11-25T17:53:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d803b49e_9dea3e11",
      "range": {
        "startLine": 102,
        "startChar": 32,
        "endLine": 102,
        "endChar": 39
      },
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f5b0e737_d8a07400",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 105,
      "author": {
        "id": 7613
      },
      "writtenOn": "2019-11-22T19:47:06Z",
      "side": 1,
      "message": "I would probably define this as a class-level constant, like kInvalidCode. Then you can check it easily from the call sites, without having to know this is defined as the max() value.\n\n(Also, for unsigned types, -1 converts to the max() value, but it\u0027s probably better to be explicit here, as you\u0027ve done.)",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b6527ac_df5cacc0",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 105,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-11-25T17:53:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f5b0e737_d8a07400",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "46d4e0ad_b267bfbc",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 5045
      },
      "writtenOn": "2019-11-22T17:35:36Z",
      "side": 1,
      "message": "Easier to write FX_SAFE_UINT32",
      "range": {
        "startLine": 113,
        "startChar": 2,
        "endLine": 113,
        "endChar": 40
      },
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "29c713a7_a4c74d6e",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-11-25T17:53:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "46d4e0ad_b267bfbc",
      "range": {
        "startLine": 113,
        "startChar": 2,
        "endLine": 113,
        "endChar": 40
      },
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ad4abd10_60efa6e7",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 115,
      "author": {
        "id": 5045
      },
      "writtenOn": "2019-11-22T17:35:36Z",
      "side": 1,
      "message": "In this patch set isn\u0027t this always true?",
      "range": {
        "startLine": 115,
        "startChar": 34,
        "endLine": 115,
        "endChar": 55
      },
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb822c9e_45f034a5",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap.cpp",
        "patchSetId": 4
      },
      "lineNbr": 115,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-11-25T17:53:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ad4abd10_60efa6e7",
      "range": {
        "startLine": 115,
        "startChar": 34,
        "endLine": 115,
        "endChar": 55
      },
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2de1dda5_cc4e5be7",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap_unittest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 9,
      "author": {
        "id": 7613
      },
      "writtenOn": "2019-11-22T19:47:06Z",
      "side": 1,
      "message": "Nit: This could be multiple tests, but each individual case is simple enough that this is probably OK.",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "87a839a8_059ddbf5",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap_unittest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 5045
      },
      "writtenOn": "2019-11-22T17:35:36Z",
      "side": 1,
      "message": "Another good test case is \"\u003c00NN\u003e\".",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2bc6db70_2a2c12eb",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap_unittest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-11-25T17:53:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "87a839a8_059ddbf5",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9e2d2c8a_31ea7126",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap_unittest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 7613
      },
      "writtenOn": "2019-11-22T19:47:06Z",
      "side": 1,
      "message": "I would add a test for FFFFFFFF, too.\n\nAlso, it would be good to cover a few encoded UTF-16BE values that use surrogate pairs, like DBFFDFFF and D800DC00, as well as unpaired surrogates like D800-DBFF and DC00-DFFF (technically invalid, but good to have test coverage for).",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "327554ee_5387ea9c",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap_unittest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-11-25T17:53:28Z",
      "side": 1,
      "message": "Agree! Those technically invalid unicodes definitely need to go into the unit tests, but right now I still need to create a test case that ToUnicode map actually matters to unicode selection (See comment #11 in chromium:1021762, some ToUnicode mapping is not being used even it exists in the pdf file), so that we can observe how Acrobat is performing regarding to strings like \"FFFFFFFF\".",
      "parentUuid": "9e2d2c8a_31ea7126",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c082c17_5cfc376d",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap_unittest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 7613
      },
      "writtenOn": "2019-11-26T03:36:31Z",
      "side": 1,
      "message": "ToUnicode mapping is used for text extraction, so I wouldn\u0027t expect any visual differences. You\u0027ll need a test that does text extraction (something along the lines of copy-and-paste), or maybe the JavaScript API can detect the difference.",
      "parentUuid": "327554ee_5387ea9c",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad4788b0_34d1936d",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap_unittest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 22,
      "author": {
        "id": 7613
      },
      "writtenOn": "2019-11-22T19:47:06Z",
      "side": 1,
      "message": "It seems like you\u0027ve tested this case twice.",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd8c4820_e666c2f2",
        "filename": "core/fpdfapi/font/cpdf_tounicodemap_unittest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 22,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-11-25T17:53:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ad4788b0_34d1936d",
      "revId": "b7715745f0e152f74fb7da5de4f59253565c4acb",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": false
    }
  ]
}