{
  "comments": [
    {
      "key": {
        "uuid": "8a88a55a_9814eb33",
        "filename": "/COMMIT_MSG",
        "patchSetId": 20
      },
      "lineNbr": 16,
      "author": {
        "id": 5045
      },
      "writtenOn": "2019-09-19T17:41:25Z",
      "side": 1,
      "message": "index, i.e. when CPDF_SimpleFont::GlyphFromCharCode() returns 0",
      "range": {
        "startLine": 15,
        "startChar": 39,
        "endLine": 16,
        "endChar": 47
      },
      "revId": "5187475752ec12938d1c73c9c850db522a15a3e6",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a900e48_862e5e3a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 20
      },
      "lineNbr": 16,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-09-19T18:51:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8a88a55a_9814eb33",
      "range": {
        "startLine": 15,
        "startChar": 39,
        "endLine": 16,
        "endChar": 47
      },
      "revId": "5187475752ec12938d1c73c9c850db522a15a3e6",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "18ad801d_b58b8955",
        "filename": "core/fpdfapi/render/cpdf_charposlist.cpp",
        "patchSetId": 20
      },
      "lineNbr": 42,
      "author": {
        "id": 5045
      },
      "writtenOn": "2019-09-19T16:10:45Z",
      "side": 1,
      "message": "Assuming we are settled on this approach and we are just adding tests at this point, here\u0027s a suggestion for avoiding some of the repeated code. WDTY of rearranging the code here this way? Please also check carefully and make sure I wrote this correctly.\n\nbool bIsInvalidGlyph \u003d GlyphID \u003d\u003d static_cast\u003cuint32_t\u003e(-1);\nbool bIsTrueTypeZeroGlyph \u003d GlyphID \u003d\u003d 0 \u0026\u0026 pFont-\u003eIsTrueTypeFont();\nbool bUseFallbackFont \u003d false;\nif (bIsInvalidGlyph || bIsTrueTypeZeroGlyph) {\n  charpos.m_FallbackFontPosition \u003d\n      pFont-\u003eFallbackFontFromCharcode(CharCode);\n  charpos.m_GlyphIndex \u003d pFont-\u003eFallbackGlyphFromCharcode(\n      charpos.m_FallbackFontPosition, CharCode);\n  if (bIsTrueTypeZeroGlyph \u0026\u0026\n      charpos.m_GlyphIndex \u003d\u003d static_cast\u003cuint32_t\u003e(-1)) {\n    // Comment goes here.\n    if (pFont-\u003eGetFontDict()-\u003eKeyExist(\"ToUnicode\"))\n      charpos.m_GlyphIndex \u003d 0;\n  } else {\n    bUseFallbackFont \u003d true;\n  }\n}\n\nCFX_Font* pCurrentFont;\nif (bUseFallbackFont) {\n  pCurrentFont \u003d pFont-\u003eGetFontFallback(charpos.m_FallbackFontPosition);\n#if defined(OS_MACOSX)\n  charpos.m_ExtGID \u003d charpos.m_GlyphIndex;\n#endif\n} else {\n  pCurrentFont \u003d pFont-\u003eGetFont();\n  charpos.m_FallbackFontPosition \u003d -1;\n}",
      "revId": "5187475752ec12938d1c73c9c850db522a15a3e6",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9acaa51b_f4755dc0",
        "filename": "core/fpdfapi/render/cpdf_charposlist.cpp",
        "patchSetId": 20
      },
      "lineNbr": 42,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-09-20T14:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "18ad801d_b58b8955",
      "revId": "5187475752ec12938d1c73c9c850db522a15a3e6",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a933dea2_b75fef2d",
        "filename": "core/fpdfapi/render/cpdf_charposlist.cpp",
        "patchSetId": 20
      },
      "lineNbr": 68,
      "author": {
        "id": 5045
      },
      "writtenOn": "2019-09-19T16:10:45Z",
      "side": 1,
      "message": "Would it be more accurate to call GetStreamFor() instead of KeyExist()?",
      "revId": "5187475752ec12938d1c73c9c850db522a15a3e6",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12ef356e_e1bc205c",
        "filename": "core/fpdfapi/render/cpdf_charposlist.cpp",
        "patchSetId": 20
      },
      "lineNbr": 68,
      "author": {
        "id": 7620
      },
      "writtenOn": "2019-09-20T14:44:29Z",
      "side": 1,
      "message": "Both GetStreamFor() and KeyExist() have been used in current code base for detecting \"ToUnicode\" objects. I would assume it\u0027s the same using either one, and KeyExist() is more convenient since no raw pointer to be handled.\n\nFor safety concern, I added \"/ToUnicode\" to a test file without adding its object, both KeyExist() and GetStreamFor() returned negative results(false/nullptr), which were the expected results and KeyExist() didn\u0027t return true just simply because the string \"ToUnicode\" exists in the PDF file.",
      "parentUuid": "a933dea2_b75fef2d",
      "revId": "5187475752ec12938d1c73c9c850db522a15a3e6",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4c50d67_13371cd2",
        "filename": "core/fpdfapi/render/cpdf_charposlist.cpp",
        "patchSetId": 20
      },
      "lineNbr": 68,
      "author": {
        "id": 5045
      },
      "writtenOn": "2019-09-20T18:23:35Z",
      "side": 1,
      "message": "A better test would be to add a bad /ToUnicode entry like: /ToUnicode /BadName, or /ToUnicode [1 2 3 4], where the value exists, but is not a stream.",
      "parentUuid": "12ef356e_e1bc205c",
      "revId": "5187475752ec12938d1c73c9c850db522a15a3e6",
      "serverId": "fca2d64a-0420-3532-b200-12848c95a47b",
      "unresolved": true
    }
  ]
}